<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>call, apply, bind - this를 명시적으로 지정하는 방법</h1>

    <p>
        JavaScript에서 모든 함수는 <code>call</code>, <code>apply</code>, <code>bind</code>라는 세 가지 메서드를 가지고 있습니다. <br>
        이 메서드들의 핵심 기능은 함수를 호출할 때 <strong><code>this</code>의 값을 명시적으로 지정</strong>하는 것입니다.
    </p>

    <h2>'this'는 왜 중요할까요?</h2>
    <p>
        JavaScript에서 <code>this</code>는 함수가 '어떻게' 호출되었는지에 따라 동적으로 결정됩니다. 이로 인해 예상치 못한 동작이 발생할 수 있습니다.
    </p>
    <script>
        const person = {
            name: '홍길동',
            greet: function() {
                console.log(`안녕하세요, 제 이름은 ${this.name}입니다.`);
            }
        };

        person.greet(); // 'person' 객체가 greet를 호출했으므로, this는 person을 가리킵니다.

        const greetFunc = person.greet;
        // greetFunc(); // 함수만 따로 호출하면, this는 전역 객체(window)를 가리키게 되어 name을 찾지 못합니다. (엄격 모드에서는 undefined)
        // Uncaught TypeError: Cannot read properties of undefined (reading 'name')
    </script>

    <hr>

    <h2>1. call()</h2>
    <p>
        <code>call()</code> 메서드는 함수를 호출하면서 <code>this</code> 값을 지정하고, 인자들을 <strong>개별적으로(쉼표로 구분하여)</strong> 전달합니다. <br>
        <code>function.call(this로 사용할 객체, 인자1, 인자2, ...)</code>
    </p>
    <script>
        const user1 = { name: '김철수' };
        const user2 = { name: '이영희' };

        function introduce(city, age) {
            console.log(`저는 ${city}에 사는 ${age}살 ${this.name}입니다.`);
        }

        // introduce 함수를 호출하되, this를 user1으로 지정
        introduce.call(user1, '서울', 30);

        // introduce 함수를 호출하되, this를 user2로 지정
        introduce.call(user2, '부산', 25);

        // 위에서 문제가 되었던 greetFunc를 call로 해결
        console.log("call을 사용한 해결:");
        greetFunc.call(person); // this를 person 객체로 명시적으로 지정
    </script>

    <hr>

    <h2>2. apply()</h2>
    <p>
        <code>apply()</code> 메서드는 <code>call()</code>과 거의 동일하지만, 인자들을 <strong>배열(또는 유사 배열 객체)</strong> 형태로 전달한다는 점이 다릅니다. <br>
        <code>function.apply(this로 사용할 객체, [인자1, 인자2, ...])</code>
    </p>
    <script>
        const admin = { name: '관리자' };

        function showDetails(role, level) {
            console.log(`이름: ${this.name}, 역할: ${role}, 레벨: ${level}`);
        }

        const adminDetails = ['시스템 관리', 5];

        // showDetails 함수를 호출하되, this를 admin으로, 인자들을 배열로 전달
        showDetails.apply(admin, adminDetails);

        // 유용한 예시: 배열에서 최대/최소값 찾기
        const numbers = [5, 2, 8, 1, 9];
        // Math.max는 this를 사용하지 않으므로 첫 번째 인자는 null이나 아무거나 넣어도 됩니다.
        const maxNumber = Math.max.apply(null, numbers);
        console.log('배열의 최대값 (apply 사용):', maxNumber); // 9
        // (참고: ES6 스프레드 문법을 사용하면 더 간단합니다: Math.max(...numbers))
    </script>

    <hr>

    <h2>3. bind()</h2>
    <p>
        <code>bind()</code> 메서드는 <code>call</code>, <code>apply</code>와 달리 함수를 <strong>즉시 실행하지 않습니다.</strong> <br>
        대신, <code>this</code> 값과 초기 인자들이 고정된(바인딩된) <strong>새로운 함수를 반환</strong>합니다. 나중에 그 새로운 함수를 호출하여 사용할 수 있습니다. <br>
        <code>const newFunction = function.bind(this로 사용할 객체, 인자1, 인자2, ...);</code>
    </p>
    <script>
        const car = {
            brand: '현대',
            name: '소나타'
        };

        function getCarInfo(year) {
            console.log(`이 차는 ${year}년식 ${this.brand} ${this.name}입니다.`);
        }

        // getCarInfo 함수의 this를 car 객체에 '묶어놓은' 새로운 함수를 생성
        const sonataInfo = getCarInfo.bind(car);

        // 나중에 필요할 때 이 함수를 호출
        sonataInfo(2023);
        sonataInfo(2024);

        // 초기 인자도 함께 바인딩할 수 있습니다.
        const sonata2025Info = getCarInfo.bind(car, 2025);
        sonata2025Info(); // 인자를 전달할 필요 없음

        // 이벤트 리스너에서 유용하게 사용됩니다.
        const button = document.createElement('button');
        button.textContent = '클릭하면 this 확인';
        document.body.appendChild(button);

        const myObject = {
            message: '버튼이 클릭되었습니다!',
            handleClick: function() {
                // 일반적인 이벤트 리스너에서 this는 이벤트를 발생시킨 요소(button)를 가리킵니다.
                // bind를 사용하면 this를 myObject로 고정할 수 있습니다.
                alert(this.message);
            }
        };

        // myObject.handleClick의 this를 myObject 자신에게 바인딩
        button.addEventListener('click', myObject.handleClick.bind(myObject));
    </script>

</body>
</html>